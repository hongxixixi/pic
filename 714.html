<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>圣杯模式</title>
    <style>
        div{
            width:200px;
            height: 100px;
            position: absolute;
           /* left: 50%;
            top: 50%;
          /*  margin-left:-100px;   把left偏的位置挪回来 
            margin-top:-50px;*/
            /* transform: translate(-50%,-50%); */
            right: 0;
            left:0;
            top: 0%;
            bottom: 0%;
            margin: auto;
            background: red;
        }
    
    </style>
</head>
<body>
    <div></div>
    <script>
    // var Person = function(){};
    // Person.prototype.sayHello = function () {
    //     console.log('hello');
    //   };
    //   Person.prototype.spell = function(){
    //       console.log("spell");
    //   };
    //   var personA = new Person();
    //   var personB = new Person();

    //   personA.sayHello();
    //   personB.spell();
      
    //   Person.prototype.sayHello = function(){
    //       console.log('你好');
    //   }

    // var grailMode = ()

// Father.prototype.lastname = 'C';
// Father.prototype.fortune = 1000000;
// function Father () {
//     this.age = 48;
// }
// function Son () {
//     this.age = 18;
//     this.waste = function () {
//         return this.fortune - 50000;
//     }
// }
// function Son1 () {
//     this.age = 19;
//     this.waste = function () {
//         return this.fortune - 10000;
//     }
// }
// var inherit = (function () { //创建圣杯inherit函数
//     function buffer () {} //buffer函数是一个闭包，仅用做一个缓冲而不做他用

// /* 使用立即函数的原因：函数执行前会进行预编译，预编译过程都会产生AO，
// 如当前案例所示，案例中的立即执行函数(注：以下简称立函)执行前预编译的AO中有buffer函数，
// 由于当立函执行完毕时会返回一个匿名函数(注：以下简称匿函)，这个匿函调用了buffer函数，
// 最终匿函也被赋予到了inherit函数中，导致立函执行前预编译产生的AO在立函执行完毕后并不会销毁，
// 于是buffer函数成为了一个闭包并被一同赋予到了inherit函数中去了，
// 这样当在外部使用inherit函数时，将会一直都在使用一个buffer函数，
// 而不用每次使用时都再新建一个buffer函数 */

// return function (targetSon, originFather) { //让目标儿子继承源头父亲
//     buffer.prototype = originFather.prototype; 
//     //targetSon.prototype = buffer.prototype; /* 不能这么写，因为这样写就相当于对象targetSon、fatherOrigin和buffer共享原型了 */
//     targetSon.prototype = new buffer(); /* 使对象targetSon试图修改自身属性时仅仅是以buffer函数作为对象进行修改，而不会影响到其他对象 */
//     targetSon.prototype.constructor = targetSon; //令目标儿子记得自己本质是谁
//     targetSon.prototype.gene = originFather; //令目标儿子记得自己的生父是谁
//     return buffer;
//     }
//     })()
// var a = inherit(Son, Father); //调用圣杯inherit函数
// var b = inherit(Son1, Father); //调用圣杯inherit函数

// Son.prototype.lastname = 'X';
// var son1 = new Son();
// var son2 = new Son();
// var father = new Father();
// console.log(son1.lastname); //控制台显示x，败家儿子成功认贼作父
// console.log(father.lastname); /* 控制台显示c，父亲自己的姓并没有因为败家儿子
//                                  通过改姓来认贼作父的惨痛事实而改变 */
// console.log(son1.constructor); //控制台显示儿子自己的构造函数(本质)
// console.log(son1.gene); //控制台显示儿子自己的生父

//    var a=5;
//    function test(){
//        a=0;
//        alert(a);      
//        alert(this.a);  
//        var a;
//        alert(a);      
//    }
//  test() ---  0  5  0
//  new test()  ---  0  undefine 0

    // function test(name,code){
    //     this.name="111";
    //     this.code="222";
    // }
    // var a = new test('11','22');
    // console.log(a.name);

    //没用到参数，返回的是--"111"
    // function foo(){
    //    bar.apply(null,arguments)
    // }
    // function bar(x){
    //    console.log(arguments)
    // }
    // foo(1,2,3,4,5)
     </script>
</body>
</html>